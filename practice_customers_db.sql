-- Task 3: Online Bookstore (Easy–Medium)
-- Scenario: You're building a small online bookstore.
-- You need to store customers (name, email which must be unique, and their city) and their orders (which customer placed it, what book title, how many copies, total price, and when the order was placed). A customer can place many orders.
CREATE EXTENSION if NOT EXISTS citext;

-- Your mission:
-- Design and create both tables with appropriate constraints. Think about what should never be empty, what should be unique, and what should auto-generate.
CREATE TABLE IF NOT EXISTS customers (
	customer_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	name VARCHAR(200) NOT NULL,
	email citext UNIQUE NOT NULL,
	city VARCHAR(150) NOT NULL
);

CREATE TABLE IF NOT EXISTS orders (
	order_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	customer_id BIGINT NOT NULL,
	book_title VARCHAR(200),
	no_of_copies INT CHECK (no_of_copies > 0),
	total_price DECIMAL(10, 2) CHECK (total_price > 0),
	created_on TIMESTAMPTZ DEFAULT current_timestamp,
	FOREIGN key (customer_id) REFERENCES customers (customer_id)
);

-- Populate with enough data so that some customers have multiple orders and at least one customer has none.
-- Done using .csv files.
SELECT
	*
FROM
	customers;

SELECT
	*
FROM
	orders;

-- Show all orders alongside customer info. 
SELECT DISTINCT
	*
FROM
	customers AS c
	RIGHT JOIN orders AS o ON c.customer_id = o.customer_id;

-- Then show ALL customers — even the ones who never ordered anything.
SELECT
	*
FROM
	customers AS c
	JOIN orders AS o ON c.customer_id = o.customer_id;

-- Find total spending per customer and who spent the most.
SELECT
	name,
	SUM(total_price)
FROM
	customers AS c
	INNER JOIN orders AS o ON c.customer_id = o.customer_id
GROUP BY
	c.customer_id,
	c.name
ORDER BY
	SUM(total_price) DESC
LIMIT
	1;

-- Clean up text data — make emails lowercase, combine name and city into one display string.
SELECT
	customer_id,
	CONCAT_WS(' from ', name, city) AS introduction,
	LOWER(email)
FROM
	customers;

-- The business now wants to track order status (new requirement that didn't exist before). Handle this structural change. Then categorize orders as delivered or still processing based on how old they are.
ALTER TABLE orders
ADD COLUMN order_status VARCHAR(20);

UPDATE orders
SET
	order_status = CASE
		WHEN created_on < '2026-01-01' THEN 'Delivered'
		ELSE 'Still Processing'
	END;

SELECT
	*
FROM
	orders;

-- Create a saved virtual table that gives a quick summary: customer name, how many orders, how much they spent total.
CREATE VIEW quick_summary AS
SELECT
	c.name,
	SUM(o.no_of_copies) AS total_orders,
	SUM(o.total_price) AS total_amount_spent
FROM
	customers c
	RIGHT JOIN orders o ON c.customer_id = o.customer_id
GROUP BY
	o.no_of_copies,
	o.total_price,
	c.name;

SELECT
	*
FROM
	quick_summary;

-- Build a reusable stored block of logic that handles placing a new order — given a customer and book details, it should insert the record.
CREATE OR REPLACE PROCEDURE place_order (
	name VARCHAR(200),
	email citext,
	city VARCHAR(150),
	book_title VARCHAR(200),
	no_of_copies INTEGER,
	total_price DECIMAL(10, 2)
) language plpgsql AS $$
DECLARE
	new_customer_id BIGINT;
BEGIN
	INSERT INTO customers (name, email, city) VALUES (name, email, city) RETURNING customer_id INTO new_customer_id;
	INSERT INTO orders (customer_id, book_title, no_of_copies, total_price) VALUES (new_customer_id, book_title, no_of_copies, total_price);
END;
$$;

CALL place_order (
	'Azeem Sarwar',
	'azeemswr.as@gmail.com',
	'Lahore',
	'Art of Seduction',
	69,
	67.69
);

SELECT
	*
FROM
	customers c
	JOIN orders o ON c.customer_id = o.customer_id;